const modelConfig = require('../config/model.config');
const logger = require('../utils/logger');
const { ModelInferenceError, FaceDetectionError } = require('../utils/errorHandler');

class FaceService {
  constructor() {
    this.modelLoaded = false;
  }

  /**
   * Initialize the face service
   */
  async initialize() {
    try {
      if (!modelConfig.isModelLoaded()) {
        await modelConfig.loadModel();
      }
      this.modelLoaded = true;
      logger.info('Face service initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize face service:', error);
      logger.warn('Face service will run in mock mode - model inference disabled');
      this.modelLoaded = false;
      // Don't throw error, allow service to start without model
    }
  }

  /**
   * Generate facial embedding from processed image data
   * @param {Float32Array} normalizedData - Normalized image pixel data
   * @returns {Promise<Array>} 512-dimensional facial embedding
   */
  async generateEmbedding(normalizedData) {
    try {
      if (!this.modelLoaded) {
        logger.warn('Model not loaded, generating mock embedding');
        // Generate a mock embedding for testing
        const mockEmbedding = new Array(512).fill(0).map(() => Math.random() * 0.1 - 0.05);
        return this.normalizeEmbedding(mockEmbedding);
      }

      logger.debug('Generating facial embedding...');
      
      // Run model inference
      const embedding = await modelConfig.runInference(normalizedData);
      
      // Validate embedding
      if (!Array.isArray(embedding) || embedding.length === 0) {
        throw new ModelInferenceError('Invalid embedding generated by model');
      }

      // Normalize the embedding vector
      const normalizedEmbedding = this.normalizeEmbedding(embedding);
      
      logger.debug(`Generated embedding with ${normalizedEmbedding.length} dimensions`);
      return normalizedEmbedding;
    } catch (error) {
      logger.error('Failed to generate embedding:', error);
      throw new ModelInferenceError('Failed to generate facial embedding');
    }
  }

  /**
   * Normalize embedding vector to unit length
   * @param {Array} embedding - Raw embedding vector
   * @returns {Array} Normalized embedding vector
   */
  normalizeEmbedding(embedding) {
    try {
      // Calculate L2 norm
      const norm = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
      
      if (norm === 0) {
        throw new ModelInferenceError('Zero-length embedding vector');
      }

      // Normalize to unit vector
      const normalized = embedding.map(val => val / norm);
      
      logger.debug(`Normalized embedding vector (norm: ${norm.toFixed(6)})`);
      return normalized;
    } catch (error) {
      logger.error('Failed to normalize embedding:', error);
      throw new ModelInferenceError('Failed to normalize embedding vector');
    }
  }

  /**
   * Validate embedding vector
   * @param {Array} embedding - Embedding vector to validate
   * @returns {boolean} True if valid
   */
  validateEmbedding(embedding) {
    try {
      if (!Array.isArray(embedding)) {
        return false;
      }

      if (embedding.length === 0) {
        return false;
      }

      // Check if all values are numbers
      if (!embedding.every(val => typeof val === 'number' && !isNaN(val))) {
        return false;
      }

      // Check for reasonable value ranges
      const hasValidRange = embedding.every(val => val >= -10 && val <= 10);
      if (!hasValidRange) {
        logger.warn('Embedding contains values outside expected range [-10, 10]');
      }

      return true;
    } catch (error) {
      logger.error('Failed to validate embedding:', error);
      return false;
    }
  }

  /**
   * Process image and generate embedding
   * @param {Buffer} imageBuffer - Image buffer
   * @returns {Promise<Object>} Processing result with embedding
   */
  async processImageAndGenerateEmbedding(imageBuffer) {
    try {
      const imageService = require('./image.service');
      
      // Process image for face detection and preprocessing
      const processedData = await imageService.processImageForVerification(imageBuffer);
      
      // Generate embedding from processed face data
      const embedding = await this.generateEmbedding(processedData.normalizedData);
      
      // Validate the generated embedding
      if (!this.validateEmbedding(embedding)) {
        throw new ModelInferenceError('Generated invalid embedding');
      }

      return {
        embedding: embedding,
        faceRegion: processedData.faceRegion,
        processedImage: processedData.processedImage
      };
    } catch (error) {
      logger.error('Failed to process image and generate embedding:', error);
      throw error;
    }
  }

  /**
   * Get model information
   * @returns {Object} Model information
   */
  getModelInfo() {
    if (!this.modelLoaded) {
      return null;
    }

    return modelConfig.getModelInfo();
  }

  /**
   * Check if model is loaded
   * @returns {boolean} True if model is loaded
   */
  isModelLoaded() {
    return this.modelLoaded && modelConfig.isModelLoaded();
  }

  /**
   * Dispose of the face service
   */
  async dispose() {
    try {
      if (this.modelLoaded) {
        await modelConfig.dispose();
        this.modelLoaded = false;
        logger.info('Face service disposed');
      }
    } catch (error) {
      logger.error('Failed to dispose face service:', error);
      throw error;
    }
  }
}

module.exports = new FaceService();
